\documentclass[a4paper]{article}

\usepackage[french]{babel}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{lmodern}


\begin{document}

	\title{\textbf{Systèmes et réseaux \\ Projet Réseaux de Kahn}}
	\author{Axel Davy \\ \'Ecole normale supérieure \and Baptiste Lefebvre \\ \'Ecole normale supérieure}
	\date{26 mai 2013}
	\maketitle


\section{Installation}

Une fois l'archive \texttt{davy-lefebvre.tgz} récupérée et les fichiers extraits placez-vous dans le répertoire \texttt{davy-lefebvre}. Dans ce répertoire la commande :
\begin{itemize}
	\item \texttt{make} : compile notre programme
\end{itemize}
Pour la désinstallation la commande :
\begin{itemize}
	\item \texttt{make clean} : efface tous les fichier qu'une des commandes précédentes a pu engendrer et ne laisse dans le répertoire que les fichiers sources
\end{itemize}
Si vous n'avez pas réussi à récupérer l'archive vous pouvez également récupérer le code source à l'aide de la commande
\begin{itemize}
	\item \texttt{git clone https://github.com/KahnProcessNetworks/KahnProcessNetworks}
\end{itemize}
en vérifiant à bien avoir installé au préalable le système de contrôle de version \texttt{git}.
 
\section{Commentaires}

\subsection{Implémentation Pipe}
Pas de commentaires particuliers

\subsection{Implémentation Network}
La toute première implémentation de Network que l'on a réalisé était assez
peu performante: On avait considéré que les put et les get étaient des
requêtes à un serveur représentant le channel. Le problème de performance
était au niveau de l'implémentation: chaque \verb!put! et \verb!get! utilisait
\verb!connect! pour se connecter au serveur, puis une fois le put et get
terminé, on fermais le socket. Des problèmes sont apparus dûs au fait que l'on réalisait
un grand nombre de connections par secondes. Les problèmes ont été résolus
en paramétrant les options des sockets,
mais l'implémentation était vraiment lente.

Finalement au lieu d'améliorer cette implémentation en gardant les
connections actives, et donc en évitant de refaire des connections à chaque
put et get, nous sommes partis sur un tout autre concept permettant
d'utiliser vraiment plusieurs machines du réseau, au lieu d'utiliser le
réseau local de notre ordinateur.

Nous avons cherché à faire une implémentation vraiment complète à ce niveau
là: au départ plusieurs machines sont en attente d'ordres et uen machine
commence le programme. Chaque \verb!doco! fait appel à des machines en
attentes pour réaliser les taches, puis met la machine ayant fait le
\verb!doco! en attente elle-même. Les machines ayant reçu un ordre font un
fork pour avoir une instance du programme qui attend des ordres et une
autre qui exécute, ce qui fait que toutes les machines sont susceptibles à
tout moment de recevoir des ordres. 

Nous avons rencontré un certain nombre de problèmes dont le plus gros étant Marshal qui ne
supportait pas les types abstraits (que l'on utilisait pour définir les
connections ouvertes). 



\subsection{Implémentation Sequential}
Notre première approche a été de considerer qu'un processus pouvait soit
terminer, soit rendre la main sans avoir terminé. Dans cette
implémentation, les processus avaient le type \verb!'a process = ('a -> unit) -> Status! avec \verb!Status! indiquant si le processus avait terminé, ou s'il fallait le rappeler. \verb!doco! devait donc appeler un à un les processus et en fonction du résultat renvoyé, savait s'il fallait rappeler le processus plus tard ou pas. 
Le problème de cette implémentation se situait au niveau de \verb!bind!:
\verb!bind e e'! devait au premier appel exécuter le processus \verb!e! et conserver son résultat, puis au second appel exécuter \verb!e'! avec le résultat conservé, mais surtout aux appels suivant conserver les modifications appliquées à \verb!e'! (qui à chaque appel pouvait évoluer). Par exemple si l'on execute le processus \verb!integers! de l'exemple donné, après n appels au processus, on se retrouve à n appels de \verb!bind! imbriqués. La complexité de l'implémentation était en O($n^2$), ce qui n'était pas satisfaisant.

Pour améliorer l'implémentation, le retour des fonctions a été remplacé par
une exception à lever si le processus devait être rappelé. Le programme
s'exécutait plus rapidement (un facteur 3 environ), mais la complexité était toujours en O($n^2$).

Finalement cette dernière implémentation a été améliorée pour renvoyer lors
de l'exception la fonction permettant d'exécuter la suite du
processus. \verb!doco! faisait ensuite appel à cette fonction et non pas au processus initial qui avait été modifié. Il n'y a donc plus le problème d'appels imbriqués et la complexité est linéaire.

Lors de nos tests, la vitesse de cette implémentation était très proche de celle de pipe.

\end{document}

